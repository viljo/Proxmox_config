# Agent Context: Self-Service Docker Platform

**Feature ID**: 002-docker-platform-selfservice
**Last Updated**: 2025-10-20
**Status**: Planning Complete - Ready for Task Generation

## Feature Summary

Build a self-service Docker platform on Proxmox VE where users can request containerized environments through a web GUI, deploy applications via GitLab CI/CD, and access them via automatic HTTPS routing. The platform provisions unprivileged LXC containers with Docker Engine, integrates Portainer for GUI management, uses Traefik for automatic TLS certificate provisioning and routing, and enforces resource quotas with auto-approval for requests within limits. Team-based ownership via LDAP groups enables collaborative environment management.

## Key Decisions

### Technology Stack
- **Container Platform**: Unprivileged LXC on Proxmox VE 9.0.3 (not VMs for performance)
- **Docker**: Docker Engine 27.x CE (not Podman - Portainer compatibility)
- **Management UI**: Portainer CE 2.21+ (not Rancher - lighter weight, LDAP integration)
- **Reverse Proxy**: Traefik v3.x (not Nginx - dynamic config, native Let's Encrypt)
- **Certificate Provider**: Let's Encrypt DNS-01 challenge (wildcard cert support)
- **Database**: PostgreSQL 16+ for platform metadata (not SQLite - concurrent writes)
- **CMDB**: NetBox for inventory tracking (already in infrastructure)
- **Authentication**: LDAP/Keycloak for user/team management

### Architecture Patterns
- **Provisioning**: Ansible playbooks triggered by API or GitLab CI
- **Deployment**: Rolling updates with health checks and automatic rollback
- **Routing**: File-based Traefik dynamic configs (not Docker labels - supports LXC backends)
- **Ownership**: Team-based via LDAP groups mapped to Portainer teams
- **Quota Enforcement**: Pre-validation with auto-approval within limits

### Resource Quotas (Defaults)
- **CPU**: 4 cores per environment
- **Memory**: 8192 MB per environment
- **Disk**: 50 GB per environment
- **Containers**: 20 containers per environment
- **Environments**: 5 per user, 10 per team

## Artifact Status

- [x] **spec.md**: Complete with 5 user stories (P1-P5), 26 functional requirements, 10 infrastructure requirements, 10 security requirements
- [x] **plan.md**: Complete with technical context, constitution check (all passed), project structure
- [x] **research.md**: Complete with 5 research questions answered (Proxmox API, Traefik config, Portainer deployment, quota enforcement, rolling updates)
- [x] **data-model.md**: Complete with 7 core entities (DockerEnvironment, Container, TraefikRoute, LDAPUser, LDAPGroup, ResourceQuota, ProvisioningRequest)
- [x] **quickstart.md**: Complete 10-step deployment guide (60-90 min setup time)
- [x] **contracts/provision_api.md**: Complete API contract for environment provisioning
- [x] **contracts/deploy_container_api.md**: Complete API contract for container deployment with rolling updates

## Implementation Priorities

### Phase 1: Core Infrastructure (P1 - Environment Provisioning)
1. Deploy PostgreSQL database for platform metadata
2. Deploy Traefik reverse proxy with Let's Encrypt
3. Deploy Portainer server with LDAP authentication
4. Implement Ansible role: `docker_platform` (LXC provisioning, Docker installation)
5. Implement quota validation and auto-approval logic
6. NetBox integration for environment registration

**Success Criteria**: Users can request environments via playbook, receive LXC with Docker + Portainer Agent, access via Portainer UI

### Phase 2: Container Deployment (P2 - Deploy Containers)
1. Implement Ansible role: `traefik_docker` (dynamic config generation)
2. Implement container deployment playbook with health checks
3. Implement rolling update with blue-green deployment
4. HTTPS routing with automatic Let's Encrypt certificates
5. Portainer UI integration for container management

**Success Criteria**: Users can deploy containers via Portainer or playbook, access via HTTPS with valid certs within 5 minutes

### Phase 3: CI/CD Integration (P3 - Automate Deployments)
1. Create GitLab CI templates for container deployment
2. Integrate Portainer API with GitLab pipelines
3. Implement webhook notifications (Slack, Mattermost, Teams)
4. Email notification system for provisioning events

**Success Criteria**: GitLab pipeline can build image, push to registry, deploy to environment automatically

### Phase 4: Monitoring & Observability (P4 - Monitor Environments)
1. Deploy Zabbix monitoring templates for LXC containers
2. Create Grafana dashboards for platform metrics
3. Implement health status aggregation API
4. Container log aggregation (Loki integration)

**Success Criteria**: Admins can view environment health, resource usage, container status in dashboards

### Phase 5: Lifecycle Management (P5 - Manage Lifecycle)
1. Implement environment deletion playbook with cleanup
2. Automated backup configuration for LXC containers
3. Resource scaling (resize CPU/memory/disk)
4. Container auto-restart on failure

**Success Criteria**: Users can delete environments cleanly, backups run automatically, scaling works without downtime

## Critical Implementation Notes

### Security Requirements
- **All secrets in Ansible Vault**: API tokens, passwords, TLS keys
- **Unprivileged LXC only**: No privileged containers, AppArmor profiles enforced
- **Network isolation**: nftables rules per environment, explicit allow-lists only
- **LDAP authentication**: Portainer, all custom APIs, no local accounts
- **Audit logging**: All provisioning, deployments, deletions logged to PostgreSQL

### Idempotency Requirements
- **LXC creation**: Check VMID exists before creating, skip if already present
- **Docker installation**: Verify Docker version before installing, upgrade if needed
- **Traefik configs**: Template to temp file, atomic move to final location
- **Portainer endpoints**: Check endpoint name exists, update if present
- **NetBox devices**: Upsert device records, update custom fields

### Performance Constraints
- **LXC provisioning**: Must complete in <5 minutes (SC-001 from spec.md)
- **Container deployment**: Must complete in <2 minutes (SC-002)
- **TLS certificate**: Must issue in <5 minutes (SC-003)
- **Webhook delivery**: Must achieve 95% success rate (SC-004)

### Constitution Compliance

All requirements validated against project constitution:

1. **Infrastructure as Code**: ✓ All roles in Ansible, no manual steps
2. **Security-First Design**: ✓ Keycloak/LDAP auth, Vault secrets, unprivileged LXC
3. **Idempotent Operations**: ✓ State checks before changes, re-runnable playbooks
4. **Single Source of Truth**: ✓ NetBox integration, monitoring from CMDB
5. **Automated Operations**: ✓ CI/CD pipeline, testing with molecule, automated backups

## Next Steps

1. **Run `/speckit.tasks`** to generate dependency-ordered task breakdown
2. **Run `/speckit.analyze`** to validate cross-artifact consistency
3. **Begin implementation** with Phase 1 (Core Infrastructure)

## Known Risks

| Risk | Mitigation |
|------|------------|
| LXC kernel nesting vulnerabilities | Unprivileged LXC + AppArmor + security updates |
| Let's Encrypt rate limits (50/week) | Wildcard certificate for all environments |
| Portainer single point of failure | Persistent volume backups, documented manual procedures |
| Traefik config file conflicts | Atomic writes, per-environment files, file locking |
| LDAP group sync delays | 5-minute sync interval documented, manual override available |

## Open Questions

1. **Web UI for requests**: Start with GitLab issues + CI/CD, add web UI later if needed
2. **IP allocation**: Use DHCP with MAC-based reservations for consistency
3. **Inter-environment networking**: Default isolation, configurable allow-lists
4. **Volume backups**: Proxmox vzdump (weekly) + NFS bind mounts for continuous backup
5. **VMID allocation**: NetBox tracking with team-based reserved ranges

## Related Documentation

- Constitution: `.specify/memory/constitution.md`
- Spec template: `.specify/templates/spec-template.md`
- Plan template: `.specify/templates/plan-template.md`
- Example spec (Google OAuth): `specs/001-google-oauth-keycloak/spec.md`

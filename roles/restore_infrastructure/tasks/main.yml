---
# Infrastructure Restore Tasks - Restore data to recreated containers

- name: Validate restore parameters
  ansible.builtin.assert:
    that:
      - restore_backup_timestamp is defined
      - restore_backup_timestamp != ""
    fail_msg: "restore_backup_timestamp is required. Set it to the backup timestamp you want to restore."

- name: Check if backup exists
  ansible.builtin.stat:
    path: "{{ restore_base_dir }}/{{ restore_backup_timestamp }}"
  register: backup_dir

- name: Fail if backup doesn't exist
  ansible.builtin.fail:
    msg: "Backup directory not found: {{ restore_base_dir }}/{{ restore_backup_timestamp }}"
  when: not backup_dir.stat.exists

- name: Load backup manifest
  ansible.builtin.include_vars:
    file: "{{ restore_base_dir }}/{{ restore_backup_timestamp }}/MANIFEST.yml"
    name: backup_manifest

- name: Display restore banner
  ansible.builtin.debug:
    msg:
      - "=========================================="
      - " INFRASTRUCTURE DATA RESTORE"
      - "=========================================="
      - "⚠️  WARNING: This will restore data to containers"
      - ""
      - "Backup timestamp: {{ restore_backup_timestamp }}"
      - "Backup location: {{ restore_base_dir }}/{{ restore_backup_timestamp }}"
      - ""
      - "PostgreSQL databases: {{ 'YES' if restore_postgresql_enabled else 'NO' }}"
      - "Redis data: {{ 'YES' if restore_redis_enabled else 'NO' }}"
      - "Docker volumes: {{ 'YES' if restore_docker_volumes_enabled else 'NO' }}"
      - ""
      - "Dry run: {{ 'YES' if restore_dry_run else 'NO' }}"
      - "Stop services: {{ 'YES' if restore_stop_services_first else 'NO' }}"
      - "=========================================="

- name: Confirmation pause
  ansible.builtin.pause:
    prompt: |

      ⚠️  CRITICAL WARNING ⚠️

      You are about to restore data to running containers.
      This operation will:
        - Stop services temporarily (if enabled)
        - Overwrite existing data
        - Replace databases with backup data
        - Replace Docker volumes with backup data

      Make sure:
        ✓ Containers are already created and running
        ✓ You have the correct backup timestamp
        ✓ You have tested with --dry_run first

      Press ENTER to continue or Ctrl+C then A to abort
  when: restore_require_confirmation and not restore_dry_run

# PostgreSQL Database Restore
- name: Restore PostgreSQL databases
  block:
    - name: Find PostgreSQL backup files
      ansible.builtin.find:
        paths: "{{ restore_base_dir }}/{{ restore_backup_timestamp }}/postgresql"
        patterns: "*.dump"
      register: postgresql_backup_files

    - name: Display databases to restore
      ansible.builtin.debug:
        msg:
          - "Found {{ postgresql_backup_files.files | length }} PostgreSQL database backups"
          - "Target host: {{ restore_postgresql_host }}:{{ restore_postgresql_port }}"

    - name: Stop services using PostgreSQL (if requested)
      ansible.builtin.command:
        cmd: "pct exec {{ item }} -- systemctl stop {{ service }}"
      loop: "{{ restore_services_to_stop_postgresql }}"
      loop_control:
        loop_var: item
      vars:
        service: "{{ restore_postgresql_service_map[item] | default('docker') }}"
      when: restore_stop_services_first and not restore_dry_run
      ignore_errors: yes

    - name: Restore PostgreSQL databases
      ansible.builtin.shell:
        cmd: |
          {% if restore_dry_run %}
          echo "[DRY RUN] Would restore database: {{ item.path | basename | regex_replace('_.*\\.dump$', '') }}"
          echo "  Source: {{ item.path }}"
          echo "  Target: {{ restore_postgresql_host }}:{{ restore_postgresql_port }}"
          {% else %}
          PGPASSWORD='{{ restore_postgresql_password }}' pg_restore \
            -h {{ restore_postgresql_host }} \
            -p {{ restore_postgresql_port }} \
            -U {{ restore_postgresql_user }} \
            -d {{ item.path | basename | regex_replace('_.*\\.dump$', '') }} \
            --clean --if-exists --no-owner --no-acl \
            {{ item.path }} 2>&1 | grep -v "^WARNING:" || true
          {% endif %}
      loop: "{{ postgresql_backup_files.files }}"
      loop_control:
        label: "{{ item.path | basename }}"
      no_log: true
      when: postgresql_backup_files.files | length > 0
      register: postgresql_restore_results

    - name: Restart services using PostgreSQL
      ansible.builtin.command:
        cmd: "pct exec {{ item }} -- systemctl start {{ service }}"
      loop: "{{ restore_services_to_stop_postgresql }}"
      loop_control:
        loop_var: item
      vars:
        service: "{{ restore_postgresql_service_map[item] | default('docker') }}"
      when: restore_stop_services_first and not restore_dry_run
      ignore_errors: yes

  when: restore_postgresql_enabled

# Redis Data Restore
- name: Restore Redis data
  block:
    - name: Find Redis backup file
      ansible.builtin.find:
        paths: "{{ restore_base_dir }}/{{ restore_backup_timestamp }}"
        patterns: "redis_*.rdb"
      register: redis_backup_file

    - name: Display Redis restore info
      ansible.builtin.debug:
        msg:
          - "Found Redis backup: {{ redis_backup_file.files[0].path if redis_backup_file.files | length > 0 else 'NONE' }}"
          - "Target container: {{ restore_redis_container_id }}"

    - name: Stop Redis service
      ansible.builtin.command:
        cmd: "pct exec {{ restore_redis_container_id }} -- systemctl stop redis-server"
      when: restore_stop_services_first and not restore_dry_run and redis_backup_file.files | length > 0
      ignore_errors: yes

    - name: Restore Redis dump file
      ansible.builtin.shell:
        cmd: |
          {% if restore_dry_run %}
          echo "[DRY RUN] Would restore Redis data from: {{ redis_backup_file.files[0].path }}"
          echo "  Target: Container {{ restore_redis_container_id }}:/var/lib/redis/dump.rdb"
          {% else %}
          pct push {{ restore_redis_container_id }} {{ redis_backup_file.files[0].path }} /var/lib/redis/dump.rdb &&
          pct exec {{ restore_redis_container_id }} -- chown redis:redis /var/lib/redis/dump.rdb &&
          pct exec {{ restore_redis_container_id }} -- chmod 640 /var/lib/redis/dump.rdb
          {% endif %}
      when: redis_backup_file.files | length > 0
      register: redis_restore_result

    - name: Start Redis service
      ansible.builtin.command:
        cmd: "pct exec {{ restore_redis_container_id }} -- systemctl start redis-server"
      when: not restore_dry_run and redis_backup_file.files | length > 0
      ignore_errors: yes

  when: restore_redis_enabled

# Docker Volumes Restore
- name: Restore Docker volumes
  block:
    - name: Find Docker volume backups
      ansible.builtin.find:
        paths: "{{ restore_base_dir }}/{{ restore_backup_timestamp }}/docker-volumes"
        patterns: "*.tar.gz"
      register: docker_volume_backups

    - name: Display volumes to restore
      ansible.builtin.debug:
        msg:
          - "Found {{ docker_volume_backups.files | length }} Docker volume backups"
          - "{% for file in docker_volume_backups.files %}  - {{ file.path | basename }}{% endfor %}"

    - name: Parse volume backup filenames
      ansible.builtin.set_fact:
        volume_restore_plan: "{{ volume_restore_plan | default([]) + [{'filename': item.path | basename, 'path': item.path, 'container': item.path | basename | regex_replace('_.*', ''), 'volume': item.path | basename | regex_replace('^[^_]+_([^_]+)_.*', '\\1')}] }}"
      loop: "{{ docker_volume_backups.files }}"
      when: docker_volume_backups.files | length > 0

    - name: Display restore plan
      ansible.builtin.debug:
        msg:
          - "Volume restore plan:"
          - "{% for vol in volume_restore_plan | default([]) %}  Container {{ restore_container_id_map[vol.container] | default('???') }}: {{ vol.volume }} <- {{ vol.filename }}{% endfor %}"

    - name: Stop Docker services
      ansible.builtin.command:
        cmd: "pct exec {{ restore_container_id_map[item.container] }} -- systemctl stop docker"
      loop: "{{ volume_restore_plan | default([]) | map(attribute='container') | unique | list }}"
      when: restore_stop_services_first and not restore_dry_run
      ignore_errors: yes

    - name: Restore Docker volumes to containers
      ansible.builtin.shell:
        cmd: |
          {% if restore_dry_run %}
          echo "[DRY RUN] Would restore:"
          echo "  Container {{ restore_container_id_map[item.container] }}: {{ restore_volume_path_map[item.container][item.volume] | default('/opt/' + item.container) }}"
          echo "  From: {{ item.path }}"
          {% else %}
          # Push archive to container
          pct push {{ restore_container_id_map[item.container] }} {{ item.path }} /tmp/restore_{{ item.filename }} &&
          # Extract in place
          pct exec {{ restore_container_id_map[item.container] }} -- tar xzf /tmp/restore_{{ item.filename }} -C {{ restore_volume_path_map[item.container][item.volume] | default('/opt/' + item.container) }} &&
          # Cleanup temp file
          pct exec {{ restore_container_id_map[item.container] }} -- rm /tmp/restore_{{ item.filename }}
          {% endif %}
      loop: "{{ volume_restore_plan | default([]) }}"
      loop_control:
        label: "{{ item.container }}/{{ item.volume }}"
      when: docker_volume_backups.files | length > 0
      register: docker_volume_restore_results

    - name: Start Docker services
      ansible.builtin.command:
        cmd: "pct exec {{ restore_container_id_map[item.container] }} -- systemctl start docker"
      loop: "{{ volume_restore_plan | default([]) | map(attribute='container') | unique | list }}"
      when: not restore_dry_run
      ignore_errors: yes

  when: restore_docker_volumes_enabled

# Verification
- name: Verify PostgreSQL database restoration
  ansible.builtin.shell:
    cmd: |
      PGPASSWORD='{{ restore_postgresql_password }}' psql \
        -h {{ restore_postgresql_host }} \
        -p {{ restore_postgresql_port }} \
        -U {{ restore_postgresql_user }} \
        -d {{ item.path | basename | regex_replace('_.*\\.dump$', '') }} \
        -c "SELECT count(*) as tables FROM pg_tables WHERE schemaname='public';" -t
  loop: "{{ postgresql_backup_files.files | default([]) }}"
  loop_control:
    label: "{{ item.path | basename | regex_replace('_.*\\.dump$', '') }}"
  no_log: true
  when:
    - restore_postgresql_enabled
    - restore_verify_after_restore
    - not restore_dry_run
    - postgresql_backup_files.files is defined
  register: database_verification

- name: Display database verification results
  ansible.builtin.debug:
    msg:
      - "Database verification:"
      - "{% for result in database_verification.results | default([]) %}  {{ result.item.path | basename | regex_replace('_.*\\.dump$', '') }}: {{ result.stdout.strip() }} tables{% endfor %}"
  when:
    - restore_postgresql_enabled
    - restore_verify_after_restore
    - not restore_dry_run
    - database_verification.results is defined

- name: Verify Redis is running
  ansible.builtin.command:
    cmd: "pct exec {{ restore_redis_container_id }} -- systemctl is-active redis-server"
  when:
    - restore_redis_enabled
    - restore_verify_after_restore
    - not restore_dry_run
  register: redis_verification
  ignore_errors: yes

- name: Display Redis verification
  ansible.builtin.debug:
    msg: "Redis service: {{ redis_verification.stdout if redis_verification is defined else 'not checked' }}"
  when:
    - restore_redis_enabled
    - restore_verify_after_restore
    - not restore_dry_run

- name: Display restore summary
  ansible.builtin.debug:
    msg:
      - "=========================================="
      - " RESTORE COMPLETE"
      - "=========================================="
      - "Backup timestamp: {{ restore_backup_timestamp }}"
      - "Dry run: {{ 'YES - No changes made' if restore_dry_run else 'NO - Data restored' }}"
      - ""
      - "PostgreSQL databases restored: {{ postgresql_backup_files.files | default([]) | length if restore_postgresql_enabled else 0 }}"
      - "Redis data restored: {{ 'YES' if restore_redis_enabled and redis_backup_file.files | default([]) | length > 0 else 'NO' }}"
      - "Docker volumes restored: {{ docker_volume_backups.files | default([]) | length if restore_docker_volumes_enabled else 0 }}"
      - ""
      - "{% if not restore_dry_run %}✓ Services have been restarted{% endif %}"
      - "{% if restore_verify_after_restore and not restore_dry_run %}✓ Verification completed{% endif %}"
      - ""
      - "Next steps:"
      - "  1. Verify applications are working correctly"
      - "  2. Check service logs for errors"
      - "  3. Test database connectivity"
      - "  4. Verify file access in Docker volumes"
      - "=========================================="
